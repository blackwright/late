{"version":3,"sources":["components/Visualizer/Visualizations/VisualizationHOC.tsx","components/Visualizer/Visualizations/Halpern/three/sceneManager.ts","components/Visualizer/Visualizations/Halpern/three/entities/polys.ts","components/Visualizer/Visualizations/Halpern/three/entities/camera.ts","components/Visualizer/Visualizations/Halpern/three/entities/renderer.ts","components/Visualizer/Visualizations/Halpern/index.tsx"],"names":["__webpack_require__","d","__webpack_exports__","wrap","react__WEBPACK_IMPORTED_MODULE_0__","react__WEBPACK_IMPORTED_MODULE_0___default","n","defaultProps","data","Uint8Array","lowPassData","options","WrappedComponent","_ref","arguments","length","undefined","rawIntensitiesRef","useRef","lowPassIntensitiesRef","startingTimestampRef","Date","now","totalDifferenceFromRawBaseline","totalDifferenceFromLowBaseline","renderedData","map","rawDataElement","i","Math","abs","lowPassDataElement","smoothing","sum","count","rangeIndex","rawIntensityMax","lowPassIntensitySum","lowPassIntensityCount","lowPassIntensityMax","current","forEach","rawIntensity","lowPassIntensity","currentRawIntensity","recentLowPassAvgIntensity","currentLowPassIntensity","concat","shift","isBeat","a","createElement","intensity","DELAY_BEFORE_ROTATING_X","CAMERA_MAX_DISTANCE","CAMERA_DRIFT","ROTATE_Y","ROTATE_X","SPHERE_SEGMENTS","sceneManager","rendererContainer","animationFrameId","segments","sceneInitializedTimestamp","t","sphereGeometry","SphereGeometry","halpern","vertices","parameters","radius","widthSegments","heightSegments","positions","Float32Array","vertex","toArray","geometry","BufferGeometry","addAttribute","BufferAttribute","attributes","position","dynamic","material","PointsMaterial","size","TextureLoader","load","alphaTest","color","transparent","Points","createPoints","camera","startingY","PerspectiveCamera","window","innerWidth","innerHeight","set","lookAt","Vector3","createCamera","renderer","_window","WebGLRenderer","alpha","setPixelRatio","devicePixelRatio","setSize","setClearColor","createRenderer","appendChild","domElement","scene","Scene","add","clock","Clock","debouncedResize","debounced","aspect","updateProjectionMatrix","render","onVisibilityChange","document","visibilityState","stop","start","addEventListener","animate","delta","getDelta","rotateY","rotateX","PI","translateY","cos","translateX","translateZ","requestAnimationFrame","cleanup","cancelAnimationFrame","removeEventListener","removeChild","remove","dispose","VisualizationHOC","rendererRef","managedSceneRef","originalVerticesRef","sphereDataSegmentsRef","vertexSegmentLengthRef","focusedDataRef","Array","fill","useEffect","managedScene","halpernGeometry","floor","array","slice","focusedDataIndex","splice","halpernBufferPositions","getAttribute","vertexSegmentIndex","ceil","dataIndex","vertexSegmentWeight","min","scalar","needsUpdate","react_default","className","ref"],"mappings":"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","file":"static/js/7.1ede6d88.chunk.js","sourcesContent":["import React, { useRef } from 'react';\nimport { Options } from './index';\nimport './Visualization.scss';\n\nexport type Props = {\n  // array of frequency data with values 0-255\n  data: Uint8Array;\n  lowPassData: Uint8Array;\n  options?: Options;\n};\n\nexport type WrappedProps = {\n  data: Uint8Array;\n  lowPassData: Uint8Array;\n  isBeat: boolean;\n  intensity: number;\n  lowPassIntensity: number;\n};\n\nconst defaultProps: Props = {\n  data: new Uint8Array(),\n  lowPassData: new Uint8Array(),\n  options: {}\n};\n\n// all visualization components should be wrapped with this HOC\nexport function wrap(\n  WrappedComponent: React.ComponentType<WrappedProps>\n): React.ComponentType<Props> {\n  return function({ data, lowPassData, options }: Props = defaultProps) {\n    const rawIntensitiesRef = useRef<number[]>([]);\n    const lowPassIntensitiesRef = useRef<number[]>([]);\n    const startingTimestampRef = useRef<number>(Date.now());\n\n    let totalDifferenceFromRawBaseline = 0;\n    let totalDifferenceFromLowBaseline = 0;\n\n    const renderedData = data.map((rawDataElement, i) => {\n      totalDifferenceFromRawBaseline += Math.abs(rawDataElement - 128);\n\n      const lowPassDataElement = lowPassData[i];\n      totalDifferenceFromLowBaseline += Math.abs(lowPassDataElement - 128);\n\n      if (options == null || !options.smoothing) {\n        return rawDataElement;\n      } else {\n        // smooth out each data value using a range of values around it,\n        // the range of this window is the value of options.smoothing\n        let sum = 0;\n        let count = 0;\n\n        let rangeIndex = i - options.smoothing;\n\n        while (rangeIndex < i + options.smoothing) {\n          const rawDataAtRangeIndex = data[rangeIndex] || 128;\n          sum += rawDataAtRangeIndex;\n          count += 1;\n          rangeIndex += 1;\n        }\n\n        return sum / count;\n      }\n    });\n\n    let rawIntensityMax = 0;\n\n    let lowPassIntensitySum = 0;\n    let lowPassIntensityCount = 0;\n    let lowPassIntensityMax = 0;\n\n    rawIntensitiesRef.current.forEach((rawIntensity, i) => {\n      if (rawIntensity > rawIntensityMax) {\n        rawIntensityMax = rawIntensity;\n      }\n\n      const lowPassIntensity = lowPassIntensitiesRef.current[i];\n      lowPassIntensitySum += lowPassIntensity;\n      lowPassIntensityCount += 1;\n\n      if (lowPassIntensity > lowPassIntensityMax) {\n        lowPassIntensityMax = lowPassIntensity;\n      }\n    });\n\n    const currentRawIntensity = totalDifferenceFromRawBaseline / data.length;\n    const recentLowPassAvgIntensity =\n      lowPassIntensitySum / lowPassIntensityCount || 0;\n\n    const currentLowPassIntensity =\n      totalDifferenceFromLowBaseline / lowPassData.length;\n\n    rawIntensitiesRef.current = rawIntensitiesRef.current.concat(\n      currentRawIntensity\n    );\n    lowPassIntensitiesRef.current = lowPassIntensitiesRef.current.concat(\n      currentLowPassIntensity\n    );\n\n    // remove intensities older than 2 seconds\n    if (Date.now() - startingTimestampRef.current > 2000) {\n      rawIntensitiesRef.current.shift();\n      lowPassIntensitiesRef.current.shift();\n    }\n\n    const isBeat = currentLowPassIntensity > recentLowPassAvgIntensity * 1.5;\n\n    return (\n      <WrappedComponent\n        data={renderedData}\n        lowPassData={lowPassData}\n        isBeat={isBeat}\n        intensity={currentRawIntensity}\n        lowPassIntensity={currentLowPassIntensity}\n      />\n    );\n  };\n}\n","import { Scene, PointsMaterial, Clock } from 'three';\nimport { createRenderer } from './entities/renderer';\nimport { createCamera } from './entities/camera';\nimport { createSphereGeometry, createPoints } from './entities/polys';\nimport { debounced } from '../../../../../utils';\n\nconst DELAY_BEFORE_ROTATING_X = 1500;\nconst CAMERA_MAX_DISTANCE = 200;\nconst CAMERA_DRIFT = 0.025;\nconst ROTATE_Y = -0.3;\nconst ROTATE_X = 0.3;\nconst SPHERE_SEGMENTS = 40;\n\nexport default function sceneManager(rendererContainer: HTMLDivElement) {\n  let animationFrameId: number;\n  let sceneInitializedTimestamp = Date.now();\n  let t = 0;\n\n  const sphereGeometry = createSphereGeometry(SPHERE_SEGMENTS);\n  const halpern = createPoints(sphereGeometry);\n  const camera = createCamera(CAMERA_MAX_DISTANCE);\n  const renderer = createRenderer();\n  rendererContainer.appendChild(renderer.domElement);\n\n  const scene = new Scene();\n  scene.add(halpern);\n\n  // clock is started in Halpern component when the\n  // animation loop is started\n  const clock = new Clock();\n\n  const debouncedResize = debounced(onResize);\n  window.addEventListener('resize', debouncedResize);\n  document.addEventListener('visibilitychange', onVisibilityChange);\n\n  function animate() {\n    const delta = clock.getDelta();\n\n    halpern.rotateY(ROTATE_Y * delta);\n\n    if (Date.now() - sceneInitializedTimestamp > DELAY_BEFORE_ROTATING_X) {\n      halpern.rotateX(ROTATE_X * delta);\n    }\n\n    t += delta;\n\n    if (t >= Math.PI * 2) {\n      t = 0;\n    }\n\n    camera.translateY(Math.cos(t) * CAMERA_DRIFT);\n    camera.translateX(Math.cos(t) * CAMERA_DRIFT);\n    camera.translateZ(Math.cos(t) * CAMERA_DRIFT * 5);\n\n    renderer.render(scene, camera);\n    animationFrameId = window.requestAnimationFrame(animate);\n  }\n\n  function onResize() {\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.updateProjectionMatrix();\n\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.render(scene, camera);\n  }\n\n  function onVisibilityChange() {\n    if (document.visibilityState === 'hidden') {\n      clock.stop();\n    } else {\n      clock.start();\n    }\n  }\n\n  function cleanup() {\n    window.cancelAnimationFrame(animationFrameId);\n    window.removeEventListener('resize', debouncedResize);\n    document.removeEventListener('visibilitychange', onVisibilityChange);\n    rendererContainer.removeChild(renderer.domElement);\n\n    scene.remove(halpern);\n\n    halpern.geometry.dispose();\n    (halpern.material as PointsMaterial).dispose();\n    sphereGeometry.dispose();\n\n    renderer.dispose();\n  }\n\n  return {\n    clock,\n    sphereGeometry,\n    halpern,\n    animate,\n    cleanup\n  };\n}\n","import {\n  Points,\n  PointsMaterial,\n  SphereGeometry,\n  BufferGeometry,\n  BufferAttribute,\n  TextureLoader\n} from 'three';\n\nexport function createSphereGeometry(segments: number): SphereGeometry {\n  return new SphereGeometry(48, segments, segments);\n}\n\nexport function createPoints(sphereGeometry: SphereGeometry): Points {\n  const pointGeometry = new SphereGeometry(\n    sphereGeometry.parameters.radius,\n    sphereGeometry.parameters.widthSegments,\n    sphereGeometry.parameters.heightSegments\n  );\n\n  const { vertices } = pointGeometry;\n  const positions = new Float32Array(vertices.length * 3);\n\n  vertices.forEach((vertex, i) => {\n    vertex.toArray(positions, i * 3);\n  });\n\n  const geometry = new BufferGeometry();\n  geometry.addAttribute('position', new BufferAttribute(positions, 3));\n  (geometry.attributes.position as BufferAttribute).dynamic = true;\n\n  const material = new PointsMaterial({\n    size: 1,\n    map: new TextureLoader().load('assets/images/point.png'),\n    alphaTest: 0.5,\n    color: 0x666666,\n    transparent: true\n  });\n\n  return new Points(geometry, material);\n}\n","import { PerspectiveCamera, Vector3 } from 'three';\n\nexport function createCamera(startingY: number) {\n  const camera = new PerspectiveCamera(\n    75,\n    window.innerWidth / window.innerHeight,\n    0.1,\n    1000\n  );\n\n  camera.position.set(0, startingY, 0);\n  camera.lookAt(new Vector3(0, 0, 0));\n\n  return camera;\n}\n","import { WebGLRenderer } from 'three';\n\nexport function createRenderer() {\n  const { innerWidth, innerHeight } = window;\n\n  const renderer = new WebGLRenderer({ alpha: true });\n  renderer.setPixelRatio(window.devicePixelRatio);\n  renderer.setSize(innerWidth, innerHeight);\n  renderer.setClearColor(0x000000, 0);\n\n  return renderer;\n}\n","import React, { useEffect, useRef } from 'react';\nimport { BufferGeometry, BufferAttribute } from 'three';\nimport * as VisualizationHOC from '../VisualizationHOC';\nimport sceneManager from './three/sceneManager';\nimport './Halpern.scss';\n\nconst RIPPLE_SPEED = 2;\nconst VERTEX_SEGMENT_WEIGHT_COEFFICIENT = 0.1;\nconst BASELINE_VERTEX_SCALAR_FACTOR = 1;\n\nconst Halpern: React.FC<VisualizationHOC.WrappedProps> = ({ data }) => {\n  const rendererRef = useRef<HTMLDivElement>(null);\n  const managedSceneRef = useRef<any>();\n  const originalVerticesRef = useRef<ArrayLike<number>>();\n  const sphereDataSegmentsRef = useRef<number>();\n  const vertexSegmentLengthRef = useRef<number>();\n  const focusedDataRef = useRef<number[]>(new Array(data.length).fill(128));\n\n  useEffect(() => {\n    const rendererContainer = rendererRef.current!;\n    const managedScene = sceneManager(rendererContainer);\n\n    managedSceneRef.current = managedScene;\n\n    const halpernGeometry = managedScene.halpern.geometry as BufferGeometry;\n\n    sphereDataSegmentsRef.current = Math.floor(\n      data.length / managedScene.sphereGeometry.parameters.widthSegments\n    );\n\n    // split vertices up into segments belonging to slices of x cross sections,\n    // first and last vertices are at top and bottom of sphere\n    vertexSegmentLengthRef.current =\n      (managedScene.sphereGeometry.vertices.length - 2) /\n      (managedScene.sphereGeometry.parameters.widthSegments - 1);\n\n    originalVerticesRef.current = (halpernGeometry.attributes.position\n      .array as Float32Array).slice(0);\n\n    managedScene.clock.start();\n\n    managedScene.animate();\n\n    return managedScene.cleanup;\n  }, []);\n\n  useEffect(() => {\n    const rippleSpeed = RIPPLE_SPEED;\n    const focusedDataIndex = Math.floor(data.length / 2);\n\n    focusedDataRef.current.splice(0, rippleSpeed);\n    focusedDataRef.current = focusedDataRef.current.concat(\n      new Array(rippleSpeed).fill(data[focusedDataIndex])\n    );\n\n    const halpernGeometry = managedSceneRef.current!.halpern.geometry;\n    const halpernBufferPositions = halpernGeometry.getAttribute('position')\n      .array as Float32Array;\n\n    let i = 0;\n    while (i < originalVerticesRef.current!.length) {\n      // find which segment the current index belongs to\n      const vertexSegmentIndex = Math.ceil(\n        Math.floor(i / 3) / vertexSegmentLengthRef.current!\n      );\n\n      const dataIndex = vertexSegmentIndex * sphereDataSegmentsRef.current!;\n      const vertexSegmentWeight = Math.min(\n        vertexSegmentIndex,\n        vertexSegmentLengthRef.current! - vertexSegmentIndex\n      );\n\n      const dataVariation =\n        Math.abs(focusedDataRef.current[dataIndex] - 128) / 255;\n\n      const scalar =\n        dataVariation *\n          vertexSegmentWeight *\n          VERTEX_SEGMENT_WEIGHT_COEFFICIENT +\n        BASELINE_VERTEX_SCALAR_FACTOR;\n\n      // update X, Y, and Z vector positions in BufferGeometry\n      halpernBufferPositions[i] = originalVerticesRef.current![i] * scalar;\n      halpernBufferPositions[i + 1] =\n        originalVerticesRef.current![i + 1] * scalar;\n      halpernBufferPositions[i + 2] =\n        originalVerticesRef.current![i + 2] * scalar;\n\n      i += 3;\n    }\n\n    // inform three.js that vertices should be repositioned,\n    // final render is handled in sceneManager animate loop\n    (halpernGeometry.getAttribute(\n      'position'\n    ) as BufferAttribute).needsUpdate = true;\n  }, [data]);\n\n  return <div className=\"halpern\" ref={rendererRef} />;\n};\n\nexport default VisualizationHOC.wrap(Halpern);\n"],"sourceRoot":""}