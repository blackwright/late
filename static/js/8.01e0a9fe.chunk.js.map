{"version":3,"sources":["components/Visualizer/Visualizations/VisualizationHOC.tsx","components/Visualizer/Visualizations/Stars/three/entities/shaders.ts","components/Visualizer/Visualizations/Stars/three/entities/polys.ts","components/Visualizer/Visualizations/Stars/three/entities/light.ts","components/Visualizer/Visualizations/Stars/three/sceneManager.ts","components/Visualizer/Visualizations/Stars/three/entities/renderer.ts","components/Visualizer/Visualizations/Stars/three/entities/camera.ts","components/Visualizer/Visualizations/Stars/index.tsx"],"names":["__webpack_require__","d","__webpack_exports__","wrap","react__WEBPACK_IMPORTED_MODULE_0__","react__WEBPACK_IMPORTED_MODULE_0___default","n","defaultProps","data","Uint8Array","lowPassData","options","WrappedComponent","_ref","arguments","length","undefined","rawIntensitiesRef","useRef","lowPassIntensitiesRef","startingTimestampRef","Date","now","totalDifferenceFromRawBaseline","totalDifferenceFromLowBaseline","renderedData","map","rawDataElement","i","Math","abs","lowPassDataElement","smoothing","sum","count","rangeIndex","rawIntensityMax","lowPassIntensitySum","lowPassIntensityCount","lowPassIntensityMax","current","forEach","rawIntensity","lowPassIntensity","currentRawIntensity","recentLowPassAvgIntensity","currentLowPassIntensity","concat","shift","isBeat","a","createElement","intensity","starVertexShader","starFragmentShader","createCloud","texture","random","geometry","PlaneGeometry","cloudMaterial","MeshLambertMaterial","TextureLoader","load","transparent","opacity","depthTest","rotateZ","cloud","Mesh","zPosition","position","set","createDirectionalLight","color","DirectionalLight","STAR_COUNT","CLOUD_COUNT","MAX_STAR_ALPHA","MIN_STAR_ALPHA","STAR_ALPHA_DELTA","ROTATE_Y","ROTATE_X","STATIC_LIGHT_COLOR","VARIABLE_LIGHT_COLOR","sceneManager","rendererContainer","lightIntensity","animationFrameId","renderer","_window","window","innerWidth","innerHeight","WebGLRenderer","antialias","setPixelRatio","devicePixelRatio","setSize","setClearColor","createRenderer","appendChild","domElement","camera","PerspectiveCamera","scene","Scene","stars","starCount","BufferGeometry","positions","Float32Array","addAttribute","BufferAttribute","alphas","attributes","j","shaderMaterial","ShaderMaterial","uniforms","type","value","Color","vertexShader","fragmentShader","Points","createStars","add","cloudCover","Group","cloudCount","aLight","AmbientLight","fixedDLight","dLight","starAlphas","alpha","alphaDirection","clock","Clock","debouncedResize","debounced","aspect","updateProjectionMatrix","render","onVisibilityChange","document","visibilityState","stop","start","addEventListener","animate","delta","getDelta","rotateX","rotateY","children","lookAt","array","needsUpdate","requestAnimationFrame","cleanup","cancelAnimationFrame","removeEventListener","removeChild","remove","dispose","material","VisualizationHOC","rendererRef","managedSceneRef","lightTimestampRef","useEffect","managedScene","currentLightIntensity","newLightIntensity","react_default","className","ref"],"mappings":"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","file":"static/js/8.01e0a9fe.chunk.js","sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\r\nimport { Options } from './index';\r\nimport './Visualization.scss';\r\n\r\nexport type Props = {\r\n  // array of frequency data with values 0-255\r\n  data: Uint8Array;\r\n  lowPassData: Uint8Array;\r\n  options?: Options;\r\n};\r\n\r\nexport type WrappedProps = {\r\n  data: Uint8Array;\r\n  lowPassData: Uint8Array;\r\n  isBeat: boolean;\r\n  intensity: number;\r\n  lowPassIntensity: number;\r\n};\r\n\r\nconst defaultProps: Props = {\r\n  data: new Uint8Array(),\r\n  lowPassData: new Uint8Array(),\r\n  options: {}\r\n};\r\n\r\n// all visualization components should be wrapped with this HOC\r\nexport function wrap(\r\n  WrappedComponent: React.ComponentType<WrappedProps>\r\n): React.ComponentType<Props> {\r\n  return function({ data, lowPassData, options }: Props = defaultProps) {\r\n    const rawIntensitiesRef = useRef<number[]>([]);\r\n    const lowPassIntensitiesRef = useRef<number[]>([]);\r\n    const startingTimestampRef = useRef<number>(Date.now());\r\n\r\n    let totalDifferenceFromRawBaseline = 0;\r\n    let totalDifferenceFromLowBaseline = 0;\r\n\r\n    const renderedData = data.map((rawDataElement, i) => {\r\n      totalDifferenceFromRawBaseline += Math.abs(rawDataElement - 128);\r\n\r\n      const lowPassDataElement = lowPassData[i];\r\n      totalDifferenceFromLowBaseline += Math.abs(lowPassDataElement - 128);\r\n\r\n      if (options == null || !options.smoothing) {\r\n        return rawDataElement;\r\n      } else {\r\n        // smooth out each data value using a range of values around it,\r\n        // the range of this window is the value of options.smoothing\r\n        let sum = 0;\r\n        let count = 0;\r\n\r\n        let rangeIndex = i - options.smoothing;\r\n\r\n        while (rangeIndex < i + options.smoothing) {\r\n          const rawDataAtRangeIndex = data[rangeIndex] || 128;\r\n          sum += rawDataAtRangeIndex;\r\n          count += 1;\r\n          rangeIndex += 1;\r\n        }\r\n\r\n        return sum / count;\r\n      }\r\n    });\r\n\r\n    let rawIntensityMax = 0;\r\n\r\n    let lowPassIntensitySum = 0;\r\n    let lowPassIntensityCount = 0;\r\n    let lowPassIntensityMax = 0;\r\n\r\n    rawIntensitiesRef.current.forEach((rawIntensity, i) => {\r\n      if (rawIntensity > rawIntensityMax) {\r\n        rawIntensityMax = rawIntensity;\r\n      }\r\n\r\n      const lowPassIntensity = lowPassIntensitiesRef.current[i];\r\n      lowPassIntensitySum += lowPassIntensity;\r\n      lowPassIntensityCount += 1;\r\n\r\n      if (lowPassIntensity > lowPassIntensityMax) {\r\n        lowPassIntensityMax = lowPassIntensity;\r\n      }\r\n    });\r\n\r\n    const currentRawIntensity = totalDifferenceFromRawBaseline / data.length;\r\n    const recentLowPassAvgIntensity =\r\n      lowPassIntensitySum / lowPassIntensityCount || 0;\r\n\r\n    const currentLowPassIntensity =\r\n      totalDifferenceFromLowBaseline / lowPassData.length;\r\n\r\n    rawIntensitiesRef.current = rawIntensitiesRef.current.concat(\r\n      currentRawIntensity\r\n    );\r\n    lowPassIntensitiesRef.current = lowPassIntensitiesRef.current.concat(\r\n      currentLowPassIntensity\r\n    );\r\n\r\n    // remove intensities older than 2 seconds\r\n    if (Date.now() - startingTimestampRef.current > 2000) {\r\n      rawIntensitiesRef.current.shift();\r\n      lowPassIntensitiesRef.current.shift();\r\n    }\r\n\r\n    const isBeat = currentLowPassIntensity > recentLowPassAvgIntensity * 1.5;\r\n\r\n    return (\r\n      <WrappedComponent\r\n        data={renderedData}\r\n        lowPassData={lowPassData}\r\n        isBeat={isBeat}\r\n        intensity={currentRawIntensity}\r\n        lowPassIntensity={currentLowPassIntensity}\r\n      />\r\n    );\r\n  };\r\n}\r\n","export const starVertexShader = `\r\nattribute float alpha;\r\nvarying float vAlpha;\r\n\r\nvoid main() {\r\n  vAlpha = alpha;\r\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n  gl_PointSize = 4.0 * alpha;\r\n  gl_Position = projectionMatrix * mvPosition;\r\n}\r\n`;\r\n\r\nexport const starFragmentShader = `\r\nuniform vec3 color;\r\nvarying float vAlpha;\r\n\r\nvoid main() {\r\n  float r = 0.0;\r\n  vec2 cxy = 2.0 * gl_PointCoord - 1.0;\r\n  r = dot(cxy, cxy);\r\n  if (r > 1.0) {\r\n    discard;\r\n  }\r\n\r\n  gl_FragColor = vec4(color, vAlpha);\r\n}\r\n`;\r\n","import {\r\n  Points,\r\n  BufferAttribute,\r\n  ShaderMaterial,\r\n  Color,\r\n  BufferGeometry,\r\n  TextureLoader,\r\n  MeshLambertMaterial,\r\n  Mesh,\r\n  PlaneGeometry\r\n} from 'three';\r\nimport { starVertexShader, starFragmentShader } from './shaders';\r\n\r\nexport function createStars(starCount: number): Points {\r\n  const geometry = new BufferGeometry();\r\n\r\n  const positions = new Float32Array(starCount * 3);\r\n\r\n  let i = 0;\r\n  while (i < starCount) {\r\n    // add random x, y, and z vector positions\r\n    positions[i++] = Math.random() * 100 - 50;\r\n    positions[i++] = Math.random() * 100 - 50;\r\n    positions[i++] = Math.random() * 100 - 50;\r\n  }\r\n\r\n  geometry.addAttribute('position', new BufferAttribute(positions, 3));\r\n\r\n  const alphas = new Float32Array(geometry.attributes.position.count * 1);\r\n\r\n  let j = 0;\r\n  while (j < alphas.length) {\r\n    alphas[j] = Math.random();\r\n    j += 1;\r\n  }\r\n\r\n  geometry.addAttribute('alpha', new BufferAttribute(alphas, 1));\r\n\r\n  const shaderMaterial = new ShaderMaterial({\r\n    uniforms: {\r\n      color: { type: 'c', value: new Color(0xffffff) }\r\n    },\r\n    vertexShader: starVertexShader,\r\n    fragmentShader: starFragmentShader,\r\n    transparent: true\r\n  });\r\n\r\n  return new Points(geometry, shaderMaterial);\r\n}\r\n\r\nexport function createCloud(): Mesh {\r\n  const texture = Math.random() < 0.5 ? 'cloud.png' : 'smoke.png';\r\n\r\n  const geometry = new PlaneGeometry(50, 50);\r\n\r\n  const cloudMaterial = new MeshLambertMaterial({\r\n    map: new TextureLoader().load(`assets/images/${texture}`),\r\n    transparent: true,\r\n    opacity: 0.15,\r\n    depthTest: false\r\n  });\r\n\r\n  geometry.rotateZ(Math.random() * 360);\r\n\r\n  const cloud = new Mesh(geometry, cloudMaterial);\r\n\r\n  const zPosition = Math.random() * 15 + 10;\r\n\r\n  cloud.position.set(\r\n    Math.random() * 100 - 50,\r\n    Math.random() * 100 - 50,\r\n    Math.random() < 0.5 ? zPosition : -zPosition\r\n  );\r\n\r\n  return cloud;\r\n}\r\n","import { DirectionalLight, AmbientLight } from 'three';\r\n\r\nexport function createAmbientLight(color: number, intensity: number) {\r\n  return new AmbientLight(color, intensity);\r\n}\r\n\r\nexport function createDirectionalLight(color: number, intensity: number) {\r\n  return new DirectionalLight(color, intensity);\r\n}\r\n","import {\r\n  Scene,\r\n  PointsMaterial,\r\n  BufferGeometry,\r\n  BufferAttribute,\r\n  Group,\r\n  Mesh,\r\n  ShaderMaterial,\r\n  Clock\r\n} from 'three';\r\nimport { createRenderer } from './entities/renderer';\r\nimport { createCamera } from './entities/camera';\r\nimport { createStars, createCloud } from './entities/polys';\r\nimport { createAmbientLight, createDirectionalLight } from './entities/light';\r\nimport { debounced } from '../../../../../utils';\r\n\r\nconst STAR_COUNT = 10 * 1000;\r\nconst CLOUD_COUNT = 40;\r\nconst MAX_STAR_ALPHA = 1.0;\r\nconst MIN_STAR_ALPHA = 0.2;\r\nconst STAR_ALPHA_DELTA = 0.75;\r\nconst ROTATE_Y = 0.025;\r\nconst ROTATE_X = 0.001;\r\nconst STATIC_LIGHT_COLOR = 0x00c4b6;\r\nconst VARIABLE_LIGHT_COLOR = 0xd10022;\r\n\r\nexport default function sceneManager(\r\n  rendererContainer: HTMLDivElement,\r\n  lightIntensity: number\r\n) {\r\n  let animationFrameId: number;\r\n\r\n  const renderer = createRenderer();\r\n  rendererContainer.appendChild(renderer.domElement);\r\n  const camera = createCamera();\r\n  const scene = new Scene();\r\n\r\n  const stars = createStars(STAR_COUNT);\r\n  scene.add(stars);\r\n\r\n  const cloudCover = new Group();\r\n\r\n  let cloudCount = 0;\r\n  while (cloudCount <= CLOUD_COUNT) {\r\n    const cloud = createCloud();\r\n    cloudCover.add(cloud);\r\n    cloudCount += 1;\r\n  }\r\n\r\n  scene.add(cloudCover);\r\n\r\n  const aLight = createAmbientLight(0xffffff, lightIntensity);\r\n  scene.add(aLight);\r\n\r\n  const fixedDLight = createDirectionalLight(STATIC_LIGHT_COLOR, 2);\r\n  fixedDLight.position.set(0, 0, 1);\r\n  scene.add(fixedDLight);\r\n\r\n  const dLight = createDirectionalLight(VARIABLE_LIGHT_COLOR, lightIntensity);\r\n  dLight.position.set(0, 0, 1);\r\n  scene.add(dLight);\r\n\r\n  // create a fixed array to track which direction to adjust each star alpha\r\n  const starAlphas = (stars.geometry as BufferGeometry).attributes.alpha;\r\n  const alphaDirection = new Float32Array(starAlphas.count);\r\n\r\n  for (let i = 0; i < alphaDirection.length; i++) {\r\n    // direction of 1 means alpha should increase\r\n    // -1 means alpha should decrease\r\n    alphaDirection[i] = Math.random() < 0.5 ? 1 : -1;\r\n  }\r\n\r\n  // clock is started in Stars component when\r\n  // the animation loop is first triggered\r\n  const clock = new Clock();\r\n\r\n  const debouncedResize = debounced(onResize);\r\n  window.addEventListener('resize', debouncedResize);\r\n  document.addEventListener('visibilitychange', onVisibilityChange);\r\n\r\n  function animate() {\r\n    const delta = clock.getDelta();\r\n\r\n    stars.rotateX(ROTATE_X * delta);\r\n    stars.rotateY(ROTATE_Y * delta);\r\n\r\n    cloudCover.rotateX(ROTATE_X * 24 * delta);\r\n    cloudCover.rotateY(ROTATE_Y * 2 * delta);\r\n    cloudCover.rotateZ(ROTATE_X * 3 * delta);\r\n\r\n    cloudCover.children.forEach(cloud => {\r\n      (cloud as Mesh).lookAt(camera.position);\r\n    });\r\n\r\n    // use alphaDirection to maintain alpha adjustment direction until we\r\n    // reach a limit, then switch the direction\r\n    for (let i = 0; i < starAlphas.count; i++) {\r\n      if (alphaDirection[i] > 0) {\r\n        (starAlphas.array as Float32Array)[i] *= 1 + STAR_ALPHA_DELTA * delta;\r\n        if ((starAlphas.array as Float32Array)[i] > MAX_STAR_ALPHA) {\r\n          alphaDirection[i] = -1;\r\n        }\r\n      } else {\r\n        (starAlphas.array as Float32Array)[i] *= 1 - STAR_ALPHA_DELTA * delta;\r\n        if ((starAlphas.array as Float32Array)[i] < MIN_STAR_ALPHA) {\r\n          alphaDirection[i] = 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    (starAlphas as BufferAttribute).needsUpdate = true;\r\n\r\n    renderer.render(scene, camera);\r\n    animationFrameId = window.requestAnimationFrame(animate);\r\n  }\r\n\r\n  function onResize() {\r\n    camera.aspect = window.innerWidth / window.innerHeight;\r\n    camera.updateProjectionMatrix();\r\n\r\n    renderer.setSize(window.innerWidth, window.innerHeight);\r\n    renderer.render(scene, camera);\r\n  }\r\n\r\n  function onVisibilityChange() {\r\n    if (document.visibilityState === 'hidden') {\r\n      clock.stop();\r\n    } else {\r\n      clock.start();\r\n    }\r\n  }\r\n\r\n  function cleanup() {\r\n    window.cancelAnimationFrame(animationFrameId);\r\n    window.removeEventListener('resize', debouncedResize);\r\n    document.removeEventListener('visibilitychange', onVisibilityChange);\r\n    rendererContainer.removeChild(renderer.domElement);\r\n\r\n    scene.remove(stars);\r\n    stars.geometry.dispose();\r\n    (stars.material as PointsMaterial).dispose();\r\n\r\n    scene.remove(cloudCover);\r\n    cloudCover.children.forEach(cloud => {\r\n      (cloud as Mesh).geometry.dispose();\r\n      ((cloud as Mesh).material as ShaderMaterial).dispose();\r\n    });\r\n\r\n    renderer.dispose();\r\n  }\r\n\r\n  return {\r\n    clock,\r\n    animate,\r\n    cleanup,\r\n    dLight\r\n  };\r\n}\r\n","import { WebGLRenderer } from 'three';\r\n\r\nexport function createRenderer() {\r\n  const { innerWidth, innerHeight } = window;\r\n\r\n  const renderer = new WebGLRenderer({ antialias: true });\r\n  renderer.setPixelRatio(window.devicePixelRatio);\r\n  renderer.setSize(innerWidth, innerHeight);\r\n  renderer.setClearColor(0x0000f, 1);\r\n\r\n  return renderer;\r\n}\r\n","import { PerspectiveCamera } from 'three';\r\n\r\nexport function createCamera() {\r\n  const camera = new PerspectiveCamera(\r\n    50,\r\n    window.innerWidth / window.innerHeight,\r\n    1,\r\n    1000\r\n  );\r\n\r\n  return camera;\r\n}\r\n","import React, { useRef, useEffect } from 'react';\r\nimport * as VisualizationHOC from '../VisualizationHOC';\r\nimport sceneManager from './three/sceneManager';\r\nimport './Stars.scss';\r\n\r\nconst MIN_DELAY_BETWEEN_INTENSITY_CHANGE = 75;\r\nconst MAX_LIGHT_INTENSITY_INCREASE_DELTA = 2.5;\r\nconst MIN_LIGHT_INTENSITY = 1;\r\n\r\nconst Stars: React.FC<VisualizationHOC.WrappedProps> = ({\r\n  data,\r\n  intensity\r\n}) => {\r\n  const rendererRef = useRef<HTMLDivElement>(null);\r\n  const managedSceneRef = useRef<any>();\r\n  const lightTimestampRef = useRef<number>(Date.now());\r\n\r\n  useEffect(() => {\r\n    const rendererContainer = rendererRef.current!;\r\n    const managedScene = sceneManager(rendererContainer, MIN_LIGHT_INTENSITY);\r\n\r\n    managedSceneRef.current = managedScene;\r\n\r\n    managedScene.clock.start();\r\n    managedScene.animate();\r\n\r\n    return managedScene.cleanup;\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    const now = Date.now();\r\n\r\n    if (now - lightTimestampRef.current <= MIN_DELAY_BETWEEN_INTENSITY_CHANGE) {\r\n      return;\r\n    }\r\n\r\n    const { dLight } = managedSceneRef.current!;\r\n\r\n    const currentLightIntensity = dLight.intensity;\r\n\r\n    let newLightIntensity = intensity / 2 || MIN_LIGHT_INTENSITY;\r\n\r\n    if (\r\n      newLightIntensity - currentLightIntensity >\r\n      MAX_LIGHT_INTENSITY_INCREASE_DELTA\r\n    ) {\r\n      newLightIntensity =\r\n        currentLightIntensity + MAX_LIGHT_INTENSITY_INCREASE_DELTA;\r\n    }\r\n\r\n    dLight.intensity = newLightIntensity;\r\n\r\n    lightTimestampRef.current = now;\r\n  }, [data]);\r\n\r\n  return <div className=\"stars\" ref={rendererRef} />;\r\n};\r\n\r\nexport default VisualizationHOC.wrap(Stars);\r\n"],"sourceRoot":""}