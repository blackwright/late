{"version":3,"sources":["components/Visualizer/Visualizations/VisualizationHOC.tsx","components/Visualizer/Visualizations/Stars/three/entities/shaders.ts","components/Visualizer/Visualizations/Stars/three/entities/polys.ts","components/Visualizer/Visualizations/Stars/three/entities/light.ts","components/Visualizer/Visualizations/Stars/three/sceneManager.ts","components/Visualizer/Visualizations/Stars/three/entities/renderer.ts","components/Visualizer/Visualizations/Stars/three/entities/camera.ts","components/Visualizer/Visualizations/Stars/index.tsx"],"names":["__webpack_require__","d","__webpack_exports__","wrap","react__WEBPACK_IMPORTED_MODULE_0__","react__WEBPACK_IMPORTED_MODULE_0___default","n","defaultProps","data","Uint8Array","lowPassData","options","WrappedComponent","_ref","arguments","length","undefined","rawIntensitiesRef","useRef","lowPassIntensitiesRef","startingTimestampRef","Date","now","totalDifferenceFromRawBaseline","totalDifferenceFromLowBaseline","renderedData","map","rawDataElement","i","Math","abs","lowPassDataElement","smoothing","sum","count","rangeIndex","rawIntensityMax","lowPassIntensitySum","lowPassIntensityCount","lowPassIntensityMax","current","forEach","rawIntensity","lowPassIntensity","currentRawIntensity","recentLowPassAvgIntensity","currentLowPassIntensity","concat","shift","isBeat","a","createElement","intensity","starVertexShader","starFragmentShader","createCloud","texture","random","geometry","PlaneGeometry","cloudMaterial","MeshLambertMaterial","TextureLoader","load","transparent","opacity","depthTest","rotateZ","cloud","Mesh","zPosition","position","set","createDirectionalLight","color","DirectionalLight","STAR_COUNT","CLOUD_COUNT","MAX_STAR_ALPHA","MIN_STAR_ALPHA","STAR_ALPHA_DELTA","ROTATE_Y","ROTATE_X","STATIC_LIGHT_COLOR","VARIABLE_LIGHT_COLOR","sceneManager","rendererContainer","lightIntensity","animationFrameId","renderer","_window","window","innerWidth","innerHeight","WebGLRenderer","antialias","setPixelRatio","devicePixelRatio","setSize","setClearColor","createRenderer","appendChild","domElement","camera","PerspectiveCamera","scene","Scene","stars","starCount","BufferGeometry","positions","Float32Array","addAttribute","BufferAttribute","alphas","attributes","j","shaderMaterial","ShaderMaterial","uniforms","type","value","Color","vertexShader","fragmentShader","Points","createStars","add","cloudCover","Group","cloudCount","aLight","AmbientLight","fixedDLight","dLight","starAlphas","alpha","alphaDirection","clock","Clock","debouncedResize","debounced","aspect","updateProjectionMatrix","render","onVisibilityChange","document","visibilityState","stop","start","addEventListener","animate","delta","getDelta","rotateX","rotateY","children","lookAt","array","needsUpdate","requestAnimationFrame","cleanup","cancelAnimationFrame","removeEventListener","removeChild","remove","dispose","material","VisualizationHOC","rendererRef","managedSceneRef","lightTimestampRef","useEffect","managedScene","currentLightIntensity","newLightIntensity","react_default","className","ref"],"mappings":"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","file":"static/js/8.5ddc88a9.chunk.js","sourcesContent":["import React, { useRef } from 'react';\nimport { Options } from './index';\nimport './Visualization.scss';\n\nexport type Props = {\n  // array of frequency data with values 0-255\n  data: Uint8Array;\n  lowPassData: Uint8Array;\n  options?: Options;\n};\n\nexport type WrappedProps = {\n  data: Uint8Array;\n  lowPassData: Uint8Array;\n  isBeat: boolean;\n  intensity: number;\n  lowPassIntensity: number;\n};\n\nconst defaultProps: Props = {\n  data: new Uint8Array(),\n  lowPassData: new Uint8Array(),\n  options: {}\n};\n\n// all visualization components should be wrapped with this HOC\nexport function wrap(\n  WrappedComponent: React.ComponentType<WrappedProps>\n): React.ComponentType<Props> {\n  return function({ data, lowPassData, options }: Props = defaultProps) {\n    const rawIntensitiesRef = useRef<number[]>([]);\n    const lowPassIntensitiesRef = useRef<number[]>([]);\n    const startingTimestampRef = useRef<number>(Date.now());\n\n    let totalDifferenceFromRawBaseline = 0;\n    let totalDifferenceFromLowBaseline = 0;\n\n    const renderedData = data.map((rawDataElement, i) => {\n      totalDifferenceFromRawBaseline += Math.abs(rawDataElement - 128);\n\n      const lowPassDataElement = lowPassData[i];\n      totalDifferenceFromLowBaseline += Math.abs(lowPassDataElement - 128);\n\n      if (options == null || !options.smoothing) {\n        return rawDataElement;\n      } else {\n        // smooth out each data value using a range of values around it,\n        // the range of this window is the value of options.smoothing\n        let sum = 0;\n        let count = 0;\n\n        let rangeIndex = i - options.smoothing;\n\n        while (rangeIndex < i + options.smoothing) {\n          const rawDataAtRangeIndex = data[rangeIndex] || 128;\n          sum += rawDataAtRangeIndex;\n          count += 1;\n          rangeIndex += 1;\n        }\n\n        return sum / count;\n      }\n    });\n\n    let rawIntensityMax = 0;\n\n    let lowPassIntensitySum = 0;\n    let lowPassIntensityCount = 0;\n    let lowPassIntensityMax = 0;\n\n    rawIntensitiesRef.current.forEach((rawIntensity, i) => {\n      if (rawIntensity > rawIntensityMax) {\n        rawIntensityMax = rawIntensity;\n      }\n\n      const lowPassIntensity = lowPassIntensitiesRef.current[i];\n      lowPassIntensitySum += lowPassIntensity;\n      lowPassIntensityCount += 1;\n\n      if (lowPassIntensity > lowPassIntensityMax) {\n        lowPassIntensityMax = lowPassIntensity;\n      }\n    });\n\n    const currentRawIntensity = totalDifferenceFromRawBaseline / data.length;\n    const recentLowPassAvgIntensity =\n      lowPassIntensitySum / lowPassIntensityCount || 0;\n\n    const currentLowPassIntensity =\n      totalDifferenceFromLowBaseline / lowPassData.length;\n\n    rawIntensitiesRef.current = rawIntensitiesRef.current.concat(\n      currentRawIntensity\n    );\n    lowPassIntensitiesRef.current = lowPassIntensitiesRef.current.concat(\n      currentLowPassIntensity\n    );\n\n    // remove intensities older than 2 seconds\n    if (Date.now() - startingTimestampRef.current > 2000) {\n      rawIntensitiesRef.current.shift();\n      lowPassIntensitiesRef.current.shift();\n    }\n\n    const isBeat = currentLowPassIntensity > recentLowPassAvgIntensity * 1.5;\n\n    return (\n      <WrappedComponent\n        data={renderedData}\n        lowPassData={lowPassData}\n        isBeat={isBeat}\n        intensity={currentRawIntensity}\n        lowPassIntensity={currentLowPassIntensity}\n      />\n    );\n  };\n}\n","export const starVertexShader = `\nattribute float alpha;\nvarying float vAlpha;\n\nvoid main() {\n  vAlpha = alpha;\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  gl_PointSize = 4.0 * alpha;\n  gl_Position = projectionMatrix * mvPosition;\n}\n`;\n\nexport const starFragmentShader = `\nuniform vec3 color;\nvarying float vAlpha;\n\nvoid main() {\n  float r = 0.0;\n  vec2 cxy = 2.0 * gl_PointCoord - 1.0;\n  r = dot(cxy, cxy);\n  if (r > 1.0) {\n    discard;\n  }\n\n  gl_FragColor = vec4(color, vAlpha);\n}\n`;\n","import {\n  Points,\n  BufferAttribute,\n  ShaderMaterial,\n  Color,\n  BufferGeometry,\n  TextureLoader,\n  MeshLambertMaterial,\n  Mesh,\n  PlaneGeometry\n} from 'three';\nimport { starVertexShader, starFragmentShader } from './shaders';\n\nexport function createStars(starCount: number): Points {\n  const geometry = new BufferGeometry();\n\n  const positions = new Float32Array(starCount * 3);\n\n  let i = 0;\n  while (i < starCount) {\n    // add random x, y, and z vector positions\n    positions[i++] = Math.random() * 100 - 50;\n    positions[i++] = Math.random() * 100 - 50;\n    positions[i++] = Math.random() * 100 - 50;\n  }\n\n  geometry.addAttribute('position', new BufferAttribute(positions, 3));\n\n  const alphas = new Float32Array(geometry.attributes.position.count * 1);\n\n  let j = 0;\n  while (j < alphas.length) {\n    alphas[j] = Math.random();\n    j += 1;\n  }\n\n  geometry.addAttribute('alpha', new BufferAttribute(alphas, 1));\n\n  const shaderMaterial = new ShaderMaterial({\n    uniforms: {\n      color: { type: 'c', value: new Color(0xffffff) }\n    },\n    vertexShader: starVertexShader,\n    fragmentShader: starFragmentShader,\n    transparent: true\n  });\n\n  return new Points(geometry, shaderMaterial);\n}\n\nexport function createCloud(): Mesh {\n  const texture = Math.random() < 0.5 ? 'cloud.png' : 'smoke.png';\n\n  const geometry = new PlaneGeometry(50, 50);\n\n  const cloudMaterial = new MeshLambertMaterial({\n    map: new TextureLoader().load(`assets/images/${texture}`),\n    transparent: true,\n    opacity: 0.15,\n    depthTest: false\n  });\n\n  geometry.rotateZ(Math.random() * 360);\n\n  const cloud = new Mesh(geometry, cloudMaterial);\n\n  const zPosition = Math.random() * 15 + 10;\n\n  cloud.position.set(\n    Math.random() * 100 - 50,\n    Math.random() * 100 - 50,\n    Math.random() < 0.5 ? zPosition : -zPosition\n  );\n\n  return cloud;\n}\n","import { DirectionalLight, AmbientLight } from 'three';\n\nexport function createAmbientLight(color: number, intensity: number) {\n  return new AmbientLight(color, intensity);\n}\n\nexport function createDirectionalLight(color: number, intensity: number) {\n  return new DirectionalLight(color, intensity);\n}\n","import {\n  Scene,\n  PointsMaterial,\n  BufferGeometry,\n  BufferAttribute,\n  Group,\n  Mesh,\n  ShaderMaterial,\n  Clock\n} from 'three';\nimport { createRenderer } from './entities/renderer';\nimport { createCamera } from './entities/camera';\nimport { createStars, createCloud } from './entities/polys';\nimport { createAmbientLight, createDirectionalLight } from './entities/light';\nimport { debounced } from '../../../../../utils';\n\nconst STAR_COUNT = 2000;\nconst CLOUD_COUNT = 20;\nconst MAX_STAR_ALPHA = 1.0;\nconst MIN_STAR_ALPHA = 0.2;\nconst STAR_ALPHA_DELTA = 0.75;\nconst ROTATE_Y = 0.025;\nconst ROTATE_X = 0.001;\nconst STATIC_LIGHT_COLOR = 0x00c4b6;\nconst VARIABLE_LIGHT_COLOR = 0xd10022;\n\nexport default function sceneManager(\n  rendererContainer: HTMLDivElement,\n  lightIntensity: number\n) {\n  let animationFrameId: number;\n\n  const renderer = createRenderer();\n  rendererContainer.appendChild(renderer.domElement);\n  const camera = createCamera();\n  const scene = new Scene();\n\n  const stars = createStars(STAR_COUNT);\n  scene.add(stars);\n\n  const cloudCover = new Group();\n\n  let cloudCount = 0;\n  while (cloudCount <= CLOUD_COUNT) {\n    const cloud = createCloud();\n    cloudCover.add(cloud);\n    cloudCount += 1;\n  }\n\n  scene.add(cloudCover);\n\n  const aLight = createAmbientLight(0xffffff, lightIntensity);\n  scene.add(aLight);\n\n  const fixedDLight = createDirectionalLight(STATIC_LIGHT_COLOR, 2);\n  fixedDLight.position.set(0, 0, 1);\n  scene.add(fixedDLight);\n\n  const dLight = createDirectionalLight(VARIABLE_LIGHT_COLOR, lightIntensity);\n  dLight.position.set(0, 0, 1);\n  scene.add(dLight);\n\n  // create a fixed array to track which direction to adjust each star alpha\n  const starAlphas = (stars.geometry as BufferGeometry).attributes.alpha;\n  const alphaDirection = new Float32Array(starAlphas.count);\n\n  for (let i = 0; i < alphaDirection.length; i++) {\n    // direction of 1 means alpha should increase\n    // -1 means alpha should decrease\n    alphaDirection[i] = Math.random() < 0.5 ? 1 : -1;\n  }\n\n  // clock is started in Stars component when\n  // the animation loop is first triggered\n  const clock = new Clock();\n\n  const debouncedResize = debounced(onResize);\n  window.addEventListener('resize', debouncedResize);\n  document.addEventListener('visibilitychange', onVisibilityChange);\n\n  function animate() {\n    const delta = clock.getDelta();\n\n    stars.rotateX(ROTATE_X * delta);\n    stars.rotateY(ROTATE_Y * delta);\n\n    cloudCover.rotateX(ROTATE_X * 24 * delta);\n    cloudCover.rotateY(ROTATE_Y * 2 * delta);\n    cloudCover.rotateZ(ROTATE_X * 3 * delta);\n\n    cloudCover.children.forEach(cloud => {\n      (cloud as Mesh).lookAt(camera.position);\n    });\n\n    // use alphaDirection to maintain alpha adjustment direction until we\n    // reach a limit, then switch the direction\n    for (let i = 0; i < starAlphas.count; i++) {\n      if (alphaDirection[i] > 0) {\n        (starAlphas.array as Float32Array)[i] *= 1 + STAR_ALPHA_DELTA * delta;\n        if ((starAlphas.array as Float32Array)[i] > MAX_STAR_ALPHA) {\n          alphaDirection[i] = -1;\n        }\n      } else {\n        (starAlphas.array as Float32Array)[i] *= 1 - STAR_ALPHA_DELTA * delta;\n        if ((starAlphas.array as Float32Array)[i] < MIN_STAR_ALPHA) {\n          alphaDirection[i] = 1;\n        }\n      }\n    }\n\n    (starAlphas as BufferAttribute).needsUpdate = true;\n\n    renderer.render(scene, camera);\n    animationFrameId = window.requestAnimationFrame(animate);\n  }\n\n  function onResize() {\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.updateProjectionMatrix();\n\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.render(scene, camera);\n  }\n\n  function onVisibilityChange() {\n    if (document.visibilityState === 'hidden') {\n      clock.stop();\n    } else {\n      clock.start();\n    }\n  }\n\n  function cleanup() {\n    window.cancelAnimationFrame(animationFrameId);\n    window.removeEventListener('resize', debouncedResize);\n    document.removeEventListener('visibilitychange', onVisibilityChange);\n    rendererContainer.removeChild(renderer.domElement);\n\n    scene.remove(stars);\n    stars.geometry.dispose();\n    (stars.material as PointsMaterial).dispose();\n\n    scene.remove(cloudCover);\n    cloudCover.children.forEach(cloud => {\n      (cloud as Mesh).geometry.dispose();\n      ((cloud as Mesh).material as ShaderMaterial).dispose();\n    });\n\n    renderer.dispose();\n  }\n\n  return {\n    clock,\n    animate,\n    cleanup,\n    dLight\n  };\n}\n","import { WebGLRenderer } from 'three';\n\nexport function createRenderer() {\n  const { innerWidth, innerHeight } = window;\n\n  const renderer = new WebGLRenderer({ antialias: true });\n  renderer.setPixelRatio(window.devicePixelRatio);\n  renderer.setSize(innerWidth, innerHeight);\n  renderer.setClearColor(0x0000f, 1);\n\n  return renderer;\n}\n","import { PerspectiveCamera } from 'three';\n\nexport function createCamera() {\n  const camera = new PerspectiveCamera(\n    50,\n    window.innerWidth / window.innerHeight,\n    1,\n    1000\n  );\n\n  return camera;\n}\n","import React, { useRef, useEffect } from 'react';\nimport * as VisualizationHOC from '../VisualizationHOC';\nimport sceneManager from './three/sceneManager';\nimport './Stars.scss';\n\nconst MAX_LIGHT_INTENSITY_INCREASE_DELTA = 2.5;\nconst MIN_LIGHT_INTENSITY = 1;\n\nconst Stars: React.FC<VisualizationHOC.WrappedProps> = ({\n  data,\n  intensity\n}) => {\n  const rendererRef = useRef<HTMLDivElement>(null);\n  const managedSceneRef = useRef<any>();\n  const lightTimestampRef = useRef<number>(Date.now());\n\n  useEffect(() => {\n    const rendererContainer = rendererRef.current!;\n    const managedScene = sceneManager(rendererContainer, MIN_LIGHT_INTENSITY);\n\n    managedSceneRef.current = managedScene;\n\n    managedScene.clock.start();\n    managedScene.animate();\n\n    return managedScene.cleanup;\n  }, []);\n\n  useEffect(() => {\n    const now = Date.now();\n\n    const { dLight } = managedSceneRef.current!;\n\n    const currentLightIntensity = dLight.intensity;\n\n    let newLightIntensity = intensity / 2 || MIN_LIGHT_INTENSITY;\n\n    if (\n      newLightIntensity - currentLightIntensity >\n      MAX_LIGHT_INTENSITY_INCREASE_DELTA\n    ) {\n      newLightIntensity =\n        currentLightIntensity + MAX_LIGHT_INTENSITY_INCREASE_DELTA;\n    }\n\n    dLight.intensity = newLightIntensity;\n\n    lightTimestampRef.current = now;\n  }, [data]);\n\n  return <div className=\"stars\" ref={rendererRef} />;\n};\n\nexport default VisualizationHOC.wrap(Stars);\n"],"sourceRoot":""}