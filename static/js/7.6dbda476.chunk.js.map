{"version":3,"sources":["components/Visualizer/Visualizations/VisualizationHOC.tsx","components/Visualizer/Visualizations/Halpern/three/sceneManager.ts","components/Visualizer/Visualizations/Halpern/three/entities/polys.ts","components/Visualizer/Visualizations/Halpern/three/entities/camera.ts","components/Visualizer/Visualizations/Halpern/three/entities/renderer.ts","components/Visualizer/Visualizations/Halpern/index.tsx"],"names":["__webpack_require__","d","__webpack_exports__","wrap","react__WEBPACK_IMPORTED_MODULE_0__","react__WEBPACK_IMPORTED_MODULE_0___default","n","defaultProps","data","Uint8Array","lowPassData","options","WrappedComponent","_ref","arguments","length","undefined","rawIntensitiesRef","useRef","lowPassIntensitiesRef","startingTimestampRef","Date","now","totalDifferenceFromRawBaseline","totalDifferenceFromLowBaseline","renderedData","map","rawDataElement","i","Math","abs","lowPassDataElement","smoothing","sum","count","rangeIndex","rawIntensityMax","lowPassIntensitySum","lowPassIntensityCount","lowPassIntensityMax","current","forEach","rawIntensity","lowPassIntensity","currentRawIntensity","recentLowPassAvgIntensity","currentLowPassIntensity","concat","shift","isBeat","a","createElement","intensity","DELAY_BEFORE_ROTATING_X","CAMERA_MAX_DISTANCE","CAMERA_DRIFT","ROTATE_Y","ROTATE_X","SPHERE_SEGMENTS","sceneManager","rendererContainer","animationFrameId","segments","sceneInitializedTimestamp","t","sphereGeometry","SphereGeometry","halpern","vertices","parameters","radius","widthSegments","heightSegments","positions","Float32Array","vertex","toArray","geometry","BufferGeometry","addAttribute","BufferAttribute","attributes","position","dynamic","material","PointsMaterial","size","TextureLoader","load","alphaTest","color","transparent","Points","createPoints","camera","startingY","PerspectiveCamera","window","innerWidth","innerHeight","set","lookAt","Vector3","createCamera","renderer","_window","WebGLRenderer","alpha","setPixelRatio","devicePixelRatio","setSize","setClearColor","createRenderer","appendChild","domElement","scene","Scene","add","clock","Clock","debouncedResize","debounced","aspect","updateProjectionMatrix","render","onVisibilityChange","document","visibilityState","stop","start","addEventListener","animate","delta","getDelta","rotateY","rotateX","PI","translateY","cos","translateX","translateZ","requestAnimationFrame","cleanup","cancelAnimationFrame","removeEventListener","removeChild","remove","dispose","VisualizationHOC","rendererRef","managedSceneRef","originalVerticesRef","sphereDataSegmentsRef","vertexSegmentLengthRef","focusedDataRef","Array","fill","useEffect","managedScene","halpernGeometry","floor","array","slice","focusedDataIndex","splice","halpernBufferPositions","getAttribute","vertexSegmentIndex","ceil","dataIndex","vertexSegmentWeight","min","scalar","needsUpdate","react_default","className","ref"],"mappings":"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","file":"static/js/7.6dbda476.chunk.js","sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\r\nimport { Options } from './index';\r\nimport './Visualization.scss';\r\n\r\nexport type Props = {\r\n  // array of frequency data with values 0-255\r\n  data: Uint8Array;\r\n  lowPassData: Uint8Array;\r\n  options?: Options;\r\n};\r\n\r\nexport type WrappedProps = {\r\n  data: Uint8Array;\r\n  lowPassData: Uint8Array;\r\n  isBeat: boolean;\r\n  intensity: number;\r\n  lowPassIntensity: number;\r\n};\r\n\r\nconst defaultProps: Props = {\r\n  data: new Uint8Array(),\r\n  lowPassData: new Uint8Array(),\r\n  options: {}\r\n};\r\n\r\n// all visualization components should be wrapped with this HOC\r\nexport function wrap(\r\n  WrappedComponent: React.ComponentType<WrappedProps>\r\n): React.ComponentType<Props> {\r\n  return function({ data, lowPassData, options }: Props = defaultProps) {\r\n    const rawIntensitiesRef = useRef<number[]>([]);\r\n    const lowPassIntensitiesRef = useRef<number[]>([]);\r\n    const startingTimestampRef = useRef<number>(Date.now());\r\n\r\n    let totalDifferenceFromRawBaseline = 0;\r\n    let totalDifferenceFromLowBaseline = 0;\r\n\r\n    const renderedData = data.map((rawDataElement, i) => {\r\n      totalDifferenceFromRawBaseline += Math.abs(rawDataElement - 128);\r\n\r\n      const lowPassDataElement = lowPassData[i];\r\n      totalDifferenceFromLowBaseline += Math.abs(lowPassDataElement - 128);\r\n\r\n      if (options == null || !options.smoothing) {\r\n        return rawDataElement;\r\n      } else {\r\n        // smooth out each data value using a range of values around it,\r\n        // the range of this window is the value of options.smoothing\r\n        let sum = 0;\r\n        let count = 0;\r\n\r\n        let rangeIndex = i - options.smoothing;\r\n\r\n        while (rangeIndex < i + options.smoothing) {\r\n          const rawDataAtRangeIndex = data[rangeIndex] || 128;\r\n          sum += rawDataAtRangeIndex;\r\n          count += 1;\r\n          rangeIndex += 1;\r\n        }\r\n\r\n        return sum / count;\r\n      }\r\n    });\r\n\r\n    let rawIntensityMax = 0;\r\n\r\n    let lowPassIntensitySum = 0;\r\n    let lowPassIntensityCount = 0;\r\n    let lowPassIntensityMax = 0;\r\n\r\n    rawIntensitiesRef.current.forEach((rawIntensity, i) => {\r\n      if (rawIntensity > rawIntensityMax) {\r\n        rawIntensityMax = rawIntensity;\r\n      }\r\n\r\n      const lowPassIntensity = lowPassIntensitiesRef.current[i];\r\n      lowPassIntensitySum += lowPassIntensity;\r\n      lowPassIntensityCount += 1;\r\n\r\n      if (lowPassIntensity > lowPassIntensityMax) {\r\n        lowPassIntensityMax = lowPassIntensity;\r\n      }\r\n    });\r\n\r\n    const currentRawIntensity = totalDifferenceFromRawBaseline / data.length;\r\n    const recentLowPassAvgIntensity =\r\n      lowPassIntensitySum / lowPassIntensityCount || 0;\r\n\r\n    const currentLowPassIntensity =\r\n      totalDifferenceFromLowBaseline / lowPassData.length;\r\n\r\n    rawIntensitiesRef.current = rawIntensitiesRef.current.concat(\r\n      currentRawIntensity\r\n    );\r\n    lowPassIntensitiesRef.current = lowPassIntensitiesRef.current.concat(\r\n      currentLowPassIntensity\r\n    );\r\n\r\n    // remove intensities older than 2 seconds\r\n    if (Date.now() - startingTimestampRef.current > 2000) {\r\n      rawIntensitiesRef.current.shift();\r\n      lowPassIntensitiesRef.current.shift();\r\n    }\r\n\r\n    const isBeat = currentLowPassIntensity > recentLowPassAvgIntensity * 1.5;\r\n\r\n    return (\r\n      <WrappedComponent\r\n        data={renderedData}\r\n        lowPassData={lowPassData}\r\n        isBeat={isBeat}\r\n        intensity={currentRawIntensity}\r\n        lowPassIntensity={currentLowPassIntensity}\r\n      />\r\n    );\r\n  };\r\n}\r\n","import { Scene, PointsMaterial, Clock } from 'three';\r\nimport { createRenderer } from './entities/renderer';\r\nimport { createCamera } from './entities/camera';\r\nimport { createSphereGeometry, createPoints } from './entities/polys';\r\nimport { debounced } from '../../../../../utils';\r\n\r\nconst DELAY_BEFORE_ROTATING_X = 1500;\r\nconst CAMERA_MAX_DISTANCE = 200;\r\nconst CAMERA_DRIFT = 0.025;\r\nconst ROTATE_Y = -0.3;\r\nconst ROTATE_X = 0.3;\r\nconst SPHERE_SEGMENTS = 60;\r\n\r\nexport default function sceneManager(rendererContainer: HTMLDivElement) {\r\n  let animationFrameId: number;\r\n  let sceneInitializedTimestamp = Date.now();\r\n  let t = 0;\r\n\r\n  const sphereGeometry = createSphereGeometry(SPHERE_SEGMENTS);\r\n  const halpern = createPoints(sphereGeometry);\r\n  const camera = createCamera(CAMERA_MAX_DISTANCE);\r\n  const renderer = createRenderer();\r\n  rendererContainer.appendChild(renderer.domElement);\r\n\r\n  const scene = new Scene();\r\n  scene.add(halpern);\r\n\r\n  // clock is started in Halpern component when the\r\n  // animation loop is started\r\n  const clock = new Clock();\r\n\r\n  const debouncedResize = debounced(onResize);\r\n  window.addEventListener('resize', debouncedResize);\r\n  document.addEventListener('visibilitychange', onVisibilityChange);\r\n\r\n  function animate() {\r\n    const delta = clock.getDelta();\r\n\r\n    halpern.rotateY(ROTATE_Y * delta);\r\n\r\n    if (Date.now() - sceneInitializedTimestamp > DELAY_BEFORE_ROTATING_X) {\r\n      halpern.rotateX(ROTATE_X * delta);\r\n    }\r\n\r\n    t += delta;\r\n\r\n    if (t >= Math.PI * 2) {\r\n      t = 0;\r\n    }\r\n\r\n    camera.translateY(Math.cos(t) * CAMERA_DRIFT);\r\n    camera.translateX(Math.cos(t) * CAMERA_DRIFT);\r\n    camera.translateZ(Math.cos(t) * CAMERA_DRIFT * 5);\r\n\r\n    renderer.render(scene, camera);\r\n    animationFrameId = window.requestAnimationFrame(animate);\r\n  }\r\n\r\n  function onResize() {\r\n    camera.aspect = window.innerWidth / window.innerHeight;\r\n    camera.updateProjectionMatrix();\r\n\r\n    renderer.setSize(window.innerWidth, window.innerHeight);\r\n    renderer.render(scene, camera);\r\n  }\r\n\r\n  function onVisibilityChange() {\r\n    if (document.visibilityState === 'hidden') {\r\n      clock.stop();\r\n    } else {\r\n      clock.start();\r\n    }\r\n  }\r\n\r\n  function cleanup() {\r\n    window.cancelAnimationFrame(animationFrameId);\r\n    window.removeEventListener('resize', debouncedResize);\r\n    document.removeEventListener('visibilitychange', onVisibilityChange);\r\n    rendererContainer.removeChild(renderer.domElement);\r\n\r\n    scene.remove(halpern);\r\n\r\n    halpern.geometry.dispose();\r\n    (halpern.material as PointsMaterial).dispose();\r\n    sphereGeometry.dispose();\r\n\r\n    renderer.dispose();\r\n  }\r\n\r\n  return {\r\n    clock,\r\n    sphereGeometry,\r\n    halpern,\r\n    animate,\r\n    cleanup\r\n  };\r\n}\r\n","import {\r\n  Points,\r\n  PointsMaterial,\r\n  SphereGeometry,\r\n  BufferGeometry,\r\n  BufferAttribute,\r\n  TextureLoader\r\n} from 'three';\r\n\r\nexport function createSphereGeometry(segments: number): SphereGeometry {\r\n  return new SphereGeometry(48, segments, segments);\r\n}\r\n\r\nexport function createPoints(sphereGeometry: SphereGeometry): Points {\r\n  const pointGeometry = new SphereGeometry(\r\n    sphereGeometry.parameters.radius,\r\n    sphereGeometry.parameters.widthSegments,\r\n    sphereGeometry.parameters.heightSegments\r\n  );\r\n\r\n  const { vertices } = pointGeometry;\r\n  const positions = new Float32Array(vertices.length * 3);\r\n\r\n  vertices.forEach((vertex, i) => {\r\n    vertex.toArray(positions, i * 3);\r\n  });\r\n\r\n  const geometry = new BufferGeometry();\r\n  geometry.addAttribute('position', new BufferAttribute(positions, 3));\r\n  (geometry.attributes.position as BufferAttribute).dynamic = true;\r\n\r\n  const material = new PointsMaterial({\r\n    size: 0.5,\r\n    map: new TextureLoader().load('assets/images/point.png'),\r\n    alphaTest: 0.5,\r\n    color: 0x666666,\r\n    transparent: true\r\n  });\r\n\r\n  return new Points(geometry, material);\r\n}\r\n","import { PerspectiveCamera, Vector3 } from 'three';\r\n\r\nexport function createCamera(startingY: number) {\r\n  const camera = new PerspectiveCamera(\r\n    75,\r\n    window.innerWidth / window.innerHeight,\r\n    0.1,\r\n    1000\r\n  );\r\n\r\n  camera.position.set(0, startingY, 0);\r\n  camera.lookAt(new Vector3(0, 0, 0));\r\n\r\n  return camera;\r\n}\r\n","import { WebGLRenderer } from 'three';\r\n\r\nexport function createRenderer() {\r\n  const { innerWidth, innerHeight } = window;\r\n\r\n  const renderer = new WebGLRenderer({ alpha: true });\r\n  renderer.setPixelRatio(window.devicePixelRatio);\r\n  renderer.setSize(innerWidth, innerHeight);\r\n  renderer.setClearColor(0x000000, 0);\r\n\r\n  return renderer;\r\n}\r\n","import React, { useEffect, useRef } from 'react';\r\nimport { BufferGeometry, BufferAttribute } from 'three';\r\nimport * as VisualizationHOC from '../VisualizationHOC';\r\nimport sceneManager from './three/sceneManager';\r\nimport './Halpern.scss';\r\n\r\nconst RIPPLE_SPEED = 3;\r\nconst VERTEX_SEGMENT_WEIGHT_COEFFICIENT = 0.1;\r\nconst BASELINE_VERTEX_SCALAR_FACTOR = 1;\r\n\r\nconst Halpern: React.FC<VisualizationHOC.WrappedProps> = ({ data }) => {\r\n  const rendererRef = useRef<HTMLDivElement>(null);\r\n  const managedSceneRef = useRef<any>();\r\n  const originalVerticesRef = useRef<ArrayLike<number>>();\r\n  const sphereDataSegmentsRef = useRef<number>();\r\n  const vertexSegmentLengthRef = useRef<number>();\r\n  const focusedDataRef = useRef<number[]>(new Array(data.length).fill(128));\r\n\r\n  useEffect(() => {\r\n    const rendererContainer = rendererRef.current!;\r\n    const managedScene = sceneManager(rendererContainer);\r\n\r\n    managedSceneRef.current = managedScene;\r\n\r\n    const halpernGeometry = managedScene.halpern.geometry as BufferGeometry;\r\n\r\n    sphereDataSegmentsRef.current = Math.floor(\r\n      data.length / managedScene.sphereGeometry.parameters.widthSegments\r\n    );\r\n\r\n    // split vertices up into segments belonging to slices of x cross sections,\r\n    // first and last vertices are at top and bottom of sphere\r\n    vertexSegmentLengthRef.current =\r\n      (managedScene.sphereGeometry.vertices.length - 2) /\r\n      (managedScene.sphereGeometry.parameters.widthSegments - 1);\r\n\r\n    originalVerticesRef.current = (halpernGeometry.attributes.position\r\n      .array as Float32Array).slice(0);\r\n\r\n    managedScene.clock.start();\r\n\r\n    managedScene.animate();\r\n\r\n    return managedScene.cleanup;\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    const rippleSpeed = RIPPLE_SPEED;\r\n    const focusedDataIndex = Math.floor(data.length / 2);\r\n\r\n    focusedDataRef.current.splice(0, rippleSpeed);\r\n    focusedDataRef.current = focusedDataRef.current.concat(\r\n      new Array(rippleSpeed).fill(data[focusedDataIndex])\r\n    );\r\n\r\n    const halpernGeometry = managedSceneRef.current!.halpern.geometry;\r\n    const halpernBufferPositions = halpernGeometry.getAttribute('position')\r\n      .array as Float32Array;\r\n\r\n    let i = 0;\r\n    while (i < originalVerticesRef.current!.length) {\r\n      // find which segment the current index belongs to\r\n      const vertexSegmentIndex = Math.ceil(\r\n        Math.floor(i / 3) / vertexSegmentLengthRef.current!\r\n      );\r\n\r\n      const dataIndex = vertexSegmentIndex * sphereDataSegmentsRef.current!;\r\n      const vertexSegmentWeight = Math.min(\r\n        vertexSegmentIndex,\r\n        vertexSegmentLengthRef.current! - vertexSegmentIndex\r\n      );\r\n\r\n      const dataVariation =\r\n        Math.abs(focusedDataRef.current[dataIndex] - 128) / 255;\r\n\r\n      const scalar =\r\n        dataVariation *\r\n          vertexSegmentWeight *\r\n          VERTEX_SEGMENT_WEIGHT_COEFFICIENT +\r\n        BASELINE_VERTEX_SCALAR_FACTOR;\r\n\r\n      // update X, Y, and Z vector positions in BufferGeometry\r\n      halpernBufferPositions[i] = originalVerticesRef.current![i] * scalar;\r\n      halpernBufferPositions[i + 1] =\r\n        originalVerticesRef.current![i + 1] * scalar;\r\n      halpernBufferPositions[i + 2] =\r\n        originalVerticesRef.current![i + 2] * scalar;\r\n\r\n      i += 3;\r\n    }\r\n\r\n    // inform three.js that vertices should be repositioned,\r\n    // final render is handled in sceneManager animate loop\r\n    (halpernGeometry.getAttribute(\r\n      'position'\r\n    ) as BufferAttribute).needsUpdate = true;\r\n  }, [data]);\r\n\r\n  return <div className=\"halpern\" ref={rendererRef} />;\r\n};\r\n\r\nexport default VisualizationHOC.wrap(Halpern);\r\n"],"sourceRoot":""}